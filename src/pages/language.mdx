import { Link } from 'gatsby-theme-material-ui';
import { Container, Box, Typography } from '@material-ui/core';

import Layout from '../components/layout';
import PageNavigation from '../components/pagenavigation';
import LinkPreview from '../components/linkpreview';
import LinkList from '../components/linklist';
import GroupByCat from '../util/processdata';

import { graphql } from 'gatsby';

export const pageQuery=graphql`
  query {
    allLanguageJson {
      nodes {
        category
        subcategory
        title
        url
        id
      }
    }
  }`

<Layout>
<PageNavigation prev="Theory" prevLink="/theory" next="Platform" nextLink="/platform">

Lorem Ipsum ... <Link to="/">Go to the main page</Link>

# Programming Language Theory (PLT)
Programming Languages are *formal languages* that are designed to be automatically executed by computer. It is due to the automatic execution requirement that the language have to be formal, that is, precisely, unambiguously and rigorously defined that it is amenable to algorithmic processing.

Normal people used to nature human language may find formal language alien - because ambiguity is a natural part of nature language - we are used to it.

Over time, a family of techniques are developed to help model these formal language, to define them, to analyze them etc - in short, they provide a toolbox and a conceptual framework to help us understand them.

## Semantics and the Big Three Paradigm
The *Big Three* Paradigm in Programmings are:

- Imperative Style
- Object Oriented Style
- Functional Style

The resources selected below are some of the best the author have seen that provide a sound theoretical foundation for building compiler/interpreters later. For Functional Style, the MPRI course goes beyond the basic semantic modelling of lambda calculus and *proves* the logical soundness of common pattern used in practical implementation. It relies on techniques such as structural induction and case analysis, comparison/bisimulation, transitive closure and defining new relations, etc. What is perhaps more surprising, and less well known, is that even the nebulous object oriented style can be rigorously modelled as well. This is done in The "Theory of Classification". A Key Theme in the series is that class is not the same as a type - instead it is more appropriately viewed as implicitly denoting a family of types. Indeed, traditionally class based inheritance has presented a challenge not entirely dissimilar to those presented by the notion of mutable variable and assignment in imperative style, as they do not fit well with the native constructs in pure math, which are our main meta-language for modelling.

<LinkList list= {GroupByCat(props.data.allLanguageJson.nodes)["plt"]["big-three"]}/>

## Special Constructs
Some Programming Languages have special programming construct that merits attention. Moreover, recent trends in computing stimulated the development of new constructs. We give some examples below.

It turns out that class based OO is not the only way to do OO. There are in fact many methods and variations: prototype-based method in Javascript, multiple inheritance and mixin, such as the CLOS(Common Lisp Object System), native, message passing implementation such as in Smalltalk, etc.

Smalltalk is an old programming language, but it is arguably the one that have stayed closer to the original spirit and vision of OO as envisioned by Alan Kay. An especially note-worthy feature (and one that may cause discomfort to some), is that in that language everything is an object, including the notion of class itself. Also, everything is done by message passing, even things that are usually regarded as core language feature such as looping, conditional, etc. The link below gives a review of these concepts, and most importantly illustrates how the object system can be bootstrapped from the *meta-class*.

Concurrent and Parallel Programming has existed since the beginning, and it is well known that they are significantly harder than classical imperative programming because of *race condition* - more fundamentally, the arbitrary nature of the intertwining of execution order (unless restricted by synchronisation) implies that there could potentially be exponentially many possible combinations. Nevertheless, the end of the Moore's Law in recent years have shifted method to accelerate computation by relying on parallelism, starting from multi-core at the hardware level. This development increased the importance of these constructs, and effectively designed constructs can increase mainstream adoption by programmers by making it less painful and error-prone to use.

As an example, Futures and Promises are two of the simplest concurrency construct there could be that provide a thin abstraction for developer. However, even with them there is a lots of subtlety once you dig beyond the surface. The chapter below is a very erudite expositions that clarify these fine prints, by situating them within the rich history associated with those concepts.

<LinkList list= {GroupByCat(props.data.allLanguageJson.nodes)["plt"]["special-constructs"]}/>

# Compilers and Interpreters
Compilers and Interpreters are different ways to make a program written in programming language - that is not directly executable by computer - executable. Compiler does so by translating it into the equivalent machine code. Interpreters does so in an online manner, by directly emulating the effect of executing that program according to its formal spec. A key insight is that Compilers and Interpreters are themselves computer program.

Over time, people have accumulated a body of knowledge on how to effectively write these class of programs.

## Modern Techniques

<LinkList list= {GroupByCat(props.data.allLanguageJson.nodes)["compilers-and-interpreters"]["modern-techniques"]}/>

## Specific Features

<LinkList list= {GroupByCat(props.data.allLanguageJson.nodes)["compilers-and-interpreters"]["specific-features"]}/>

## Misc

<LinkList list= {GroupByCat(props.data.allLanguageJson.nodes)["compilers-and-interpreters"]["misc"]}/>


</PageNavigation>
</Layout>
